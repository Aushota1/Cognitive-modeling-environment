Task_1

Сроки выполнения:
- Начало: 
- Конец: 

Ответственные:
- ///
- ///


Дополнительные ресурсы:
https://github.com/Aushota1/Cognitive-modeling-environment.git
git remote add origin https://github.com/Aushota1/Cognitive-modeling-environment.git
git branch -M main
git push -u origin main


Описание задания:

Основная грамматика

1. Sp_father(<my_world>, ^father_world world1) {
2. Sp(<humans>, ^world people) {
3. State(<name_state>, ^problem school_people) {
4.     Init.<people_1>(^type person, ^name Jon);
5.     Init.<people_2>(^type person, ^name Ron);
6.
7.
8.
9.     Init.<people_3>(^type person, ^name Den);
10.
11.  ^Global_type things[<people_1>, <people_2>, <people_3>];
12.};
12. };
13. Write("......");
14. };


1. Создание некого мира, где `my_world` — это текущий мир, а `^father_world world1` — это мир-родитель.
2. Группа (или спектр) в контексте некоторого мира и что в ней есть люди (`humans` — название группы, `^world_peoples` — ссылка на мир).
3. Некое состояние, называемое `name_state`, которое связано с определённой проблемой (`^problem_school_people`).
4–10. Инициализация участников, задавая тип (`type_person`) и имя (`name`). У нас есть разные типы людей, и каждый из них имеет уникальное имя.
11. Создаётся глобальный массив или коллекция вещей, в которой есть все инициализированные объекты.
Для обеспечения коммуникации и связи между объектами, мирами, проблемами и их состояниями используются специальные ссылки на типы атрибутов, обозначенные символом «^». Это позволяет в дальнейшем по проблеме или ссылке на объект определить, в каком мире он находится и как он влияет на этот мир (какое положение и характеристики имеет и к какой проблеме относится).
В качестве атрибутов можно использовать любые понятные значения, которые определяют класс объекта, мира или его тип. Атрибуты более высокого ранга, например, атрибуты класса текущего мира, присваиваются всем последующим объектам, созданным в этом мире.


Пример этапов обработки 
Лексический анализ:
На этом этапе компилятор разбивает исходный код на токены (ключевые слова, идентификаторы, литералы и т. д.). В нашем случае: init, ., <, people_2>, (, ^type, person, ,, ^name, Ron, ).
Также здесь проверяется корректность синтаксиса и выявляются ошибки.
Синтаксический анализ (парсинг):
Создаётся синтаксическое дерево, представляющее структуру программы. В нашем случае, это может быть дерево с корневым узлом Init, двумя дочерними узлами Type и Name, и далее — узлы Person и Ron.
Проверяется соответствие структуры программы грамматике языка.

Общий вид в грамматике 

Sp_father( <name>, ^atr name_atr) {
Sp (<name>, ^atr name_atr){
	State(<name_state>, ^atr name_atr){
		Init.<name_1> (^atr name_atr, ^atr name_atr);
                 Init.<name_2> (^atr name_atr, ^atr name_atr);
		.
		.
		.
                 Init.<name_n> (^atr name_atr, ^atr name_atr);

		^atr [<name_1>, <name_2> … <name_n>];
	}
Write(“……”);
}
}

При разработке лексера важным шагом является создание классов токенов, соответствующих нашему алфавиту. Основная задача заключается в разбиении исходного кода на токены и последующем построении синтаксического дерева. Для достижения этой цели работу следует разбить на несколько этапов.
- Определение классов токенов:
Каждый токен будет относиться к своему уникальному классу, либо будет включен в группы символов, объединенных по смысловой нагрузке
- Парсинг кода:
Во время парсинга кода лексер будет проверять, присутствует ли конкретный символ в нашем конечном алфавите, и в зависимости от этого будет присваивать класс, к которому относится этот символ.

Основные классы 
Алфавит языка программирования:
- VAR - Переменные:
- a, b, c - переменные для идентификации объектов (например, имя человека).
- NUM - Числа:
- 0-9 - цифровые значения, которые могут быть использованы в вычислениях или счетах.
- MUL - Операторы:
- - - символ умножения (может быть расширен для других операторов, если это необходимо).
- ASIGN - Присвоение:
- := - символ для присвоения значений.
- SEMICOLON - Конец строки:
- ; - символ для завершения команды (но может использоваться в различных контекстах).
- CONTROL - Управляющие команды:
- Sp - инициализация мира.
- Sp_father - корневой мир.
- State - определение состояния.
- Write - итератор для вывода.
- BLOCK - Структурные символы:
- { } - начало и конец блока кода (итератора).
- < > - начало и конец имени (или аргумента функции).
- - начало и конец множества имен или переменных.
- ATTRIBUTE - Атрибуты:
- ^ - символ присвоения атрибута, указывающий на то, что элемент с этим символом связан с типом или значением.
- TEXT - Текстовые строки:
- " " - начало и конец текстовых строк. Итд ........... 

Правила 

После того как мы определим алфавит для нашего языка, можно переходить к разработке правил парсинга. На этом этапе для оптимизации работы компилятора и предотвращения потенциальных проблем на стадии синтаксического анализа мы должны формализовать правила парсинга. При нарушении этих правил мы будем выбрасывать ошибки и приостанавливать построение синтаксического дерева, продолжая обработку только "корректного кода".
Важно отметить, что на данном этапе нельзя установить строгие нормы, требуемые синтаксическим анализатором, однако возможно прописать правила для явных и грубых нарушений с помощью регулярных выражений и флагов.
Одним из ключевых правил станет обработка кода с учетом языка "Дика" — это будет заключаться в проверке на корректное закрытие скобок всех типов у всех итераторов. Для этого мы будем парсить код как с начала, так и с конца, используя указатели, и запоминать индексы открывающих скобок (входные символы для итераторов и имен). Далее мы будем проверять наличие соответствующих закрывающих скобок. Таким образом, мы сможем исключить обработку незаконченных (ошибочных) частей кода и формировать дерево только из правильно написанных и завершенных фрагментов.
Также важным аспектом станет предоставление пользователю возможности избежать ошибок компиляции. Мы будем учитывать строгие правила синтаксиса и регистра, используя метод регулярных выражений, отличающийся от порождающих грамматик и синтаксических диаграмм. Это позволит усложнить и уточнить правила парсинга, повысив надежность компиляции.
Например, после определения регулярных выражений запись "SP" будет корректной так же, как и "sp".



Основные правила:
- Проверка на язык – идентификация языка программирования для дальнейшего анализа.
- Проверка на оформление кода – соблюдение соглашений о коде, аналогично примеру, приведённому по ссылке: .https://www.oracle.com/java/technologies/javase/codeconventions-contents.html
- Частичная проверка на инициализацию – основная проверка ожидаемых символов при написании компилятора происходит уже после составления дерева разбора в синтаксическом анализаторе. Однако на этом этапе можно прописать некоторые правила и исключить ошибки. Например, при создании объекта в его параметры мы передаем ( ^atr name_atr, ^atr name_atr), и на входе ожидаем именно эту конструкцию.
- Проверка на переход и завершенность “;” – контроль за наличием завершающего символа ";".
- Проверка на комментарии “//” – проверка наличия однострочных комментариев.
- Проверка через регулярные выражения – задание со звездочкой ;)

TO-DO list 
1.Прописать алфавит и определить классы/группы классов символов
2.Создать правила парсинга для определения типа/класса переменной, символа или оператора 
3.Разработать регулярные выражения для парсера
4.Составить документацию по соблюдению соглашений о коде
5.Собрать конечный парсер с готовой грамматикой и правилами

Критерии:

!!!Для уважения труда и нервов каждого лучше не собирать весь код с правилами и регулярными выражениями в одном файле. Лучше разбивать это на несколько файлов, каждый из которых будет отвечать за конкретный тип или класс символов. Это позволит в дальнейшем при сборке парсера подключать только необходимые модули и упрощать поддержку и развитие кода.
Рекомендации по структуре файлов:
- Типы переменных:
- int_variables
- float_variables
- string_variables
- и т.д.
- Операторы:
- arithmetic_operators
- logical_operators
- comparison_operators
- Правила парсинга:
- parsing_rules
- grammar
- Регулярные выражения:
- regex_patterns
Преимущества разделения:
- Читаемость: Код становится более структурированным и читаемым.
- Поддержка: Упрощается процесс исправления ошибок и добавления новых возможностей.
- Модульность: Возможность легко использовать код в различных частях проекта.
!!!


